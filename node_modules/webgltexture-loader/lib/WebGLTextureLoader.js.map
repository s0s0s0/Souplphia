{"version":3,"sources":["../src/WebGLTextureLoader.js"],"names":["WebGLTextureLoader","gl","input"],"mappings":";;;;;;;;;;AAQA;;;IAGqBA,kB;;AAMnB;;;AAGA,8BAAYC,EAAZ,EAAuC;AAAA;;AACrC,SAAKA,EAAL,GAAUA,EAAV;AACD;;AAED;;;;AAZA;;;;;AAiBA;;;;;AAKA;;;;;;AAMA;;;;;;;;;;AAMA;;;;2BAIOC,K,EAAgB;AACrB;AACD;;;;;;kBAzCkBF,kB","file":"WebGLTextureLoader.js","sourcesContent":["//@flow\n\nexport type TextureAndSize = {\n  texture: WebGLTexture,\n  width: number,\n  height: number\n};\n\n/**\n * a WebGLTextureLoader handle the loading of WebGLTexture for a given input object.\n */\nexport default class WebGLTextureLoader<T> {\n  /**\n   * @property {WebGLRenderingContext} gl - the contextual rendering context\n   */\n  gl: WebGLRenderingContext;\n\n  /**\n   *\n   */\n  constructor(gl: WebGLRenderingContext) {\n    this.gl = gl;\n  }\n\n  /**\n   * Cancel and clear everything\n   */\n  +dispose: () => void;\n\n  /**\n   * Check if the loader can handle a given input\n   */\n  +canLoad: (input: any) => boolean;\n\n  /**\n   * Load the resource by its input. returns a promise of {texture,width,height}.\n   * idempotent: If load() is called twice with the same input, same promise is returned.\n   */\n  +load: (input: T) => Promise<TextureAndSize>;\n\n  /**\n   * try to get in sync the texture for a given input. otherwise null/undefined.\n   * If null is returned, load() can be called in order to load the resource that will then be available in a future get() call.\n   */\n  +get: (input: T) => ?TextureAndSize;\n\n  /**\n   * sync the webgl texture with a loaded input. for instance for <video>/<canvas> elements this needs to be called recurrently (like in a requestAnimationFrame loop) to get the texture updated.\n   * update should only get called IF get(input) was returning a result.\n   */\n  update(input: T): void {\n    // Default implementation don't do anything which works for all static content like an image\n  }\n}\n"]}