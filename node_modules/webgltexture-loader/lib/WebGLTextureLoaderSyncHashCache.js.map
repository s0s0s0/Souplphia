{"version":3,"sources":["../src/WebGLTextureLoaderSyncHashCache.js"],"names":["WebGLTextureLoaderSyncHashCache","results","Map","promises","_disposed","gl","forEach","disposeTexture","r","texture","clear","deleteTexture","input","hash","inputHash","result","get","freshResult","getNoCache","set","existing","promise","Promise","resolve"],"mappings":";;;;;;;;AACA;;;;;;;;;;;;IAGMA,+B;;;;;;;;;;;;;;wOAMJC,O,GAAkC,IAAIC,GAAJ,E,QAClCC,Q,GAA4C,IAAID,GAAJ,E,QAE5CE,S,GAAY,K;;AARZ;;AAEA;;;;;8BAOU;AAAA;;AAAA,UACAC,EADA,GAC0B,IAD1B,CACAA,EADA;AAAA,UACIJ,OADJ,GAC0B,IAD1B,CACIA,OADJ;AAAA,UACaE,QADb,GAC0B,IAD1B,CACaA,QADb;;AAERF,cAAQK,OAAR,CAAgB,aAAK;AACnB,eAAKC,cAAL,CAAoBC,EAAEC,OAAtB;AACD,OAFD;AAGAR,cAAQS,KAAR;AACAP,eAASO,KAAT;AACA,WAAKN,SAAL,GAAiB,IAAjB;AACD;;;mCAEcK,O,EAAuB;AACpC,WAAKJ,EAAL,CAAQM,aAAR,CAAsBF,OAAtB;AACD;;;wBAEGG,K,EAAU;AACZ,UAAMC,OAAO,KAAKC,SAAL,CAAeF,KAAf,CAAb;AACA,UAAMG,SAAS,KAAKd,OAAL,CAAae,GAAb,CAAiBH,IAAjB,CAAf;AACA,UAAIE,MAAJ,EAAY,OAAOA,MAAP;AACZ,UAAME,cAAc,KAAKC,UAAL,CAAgBN,KAAhB,CAApB;AACA,WAAKX,OAAL,CAAakB,GAAb,CAAiBN,IAAjB,EAAuBI,WAAvB;AACA,aAAOA,WAAP;AACD;;AAED;;;;yBACKL,K,EAAU;AACb,UAAMC,OAAO,KAAKC,SAAL,CAAeF,KAAf,CAAb;AACA,UAAMQ,WAAW,KAAKjB,QAAL,CAAca,GAAd,CAAkBH,IAAlB,CAAjB;AACA,UAAIO,QAAJ,EAAc,OAAOA,QAAP;AACd,UAAMC,UAAUC,QAAQC,OAAR,CAAgB,KAAKP,GAAL,CAASJ,KAAT,CAAhB,CAAhB;AACA,WAAKT,QAAL,CAAcgB,GAAd,CAAkBN,IAAlB,EAAwBQ,OAAxB;AACA,aAAOA,OAAP;AACD;;;;;;kBAGYrB,+B","file":"WebGLTextureLoaderSyncHashCache.js","sourcesContent":["//@flow\nimport WebGLTextureLoader from \"./WebGLTextureLoader\";\nimport type { TextureAndSize } from \"./WebGLTextureLoader\";\n\nclass WebGLTextureLoaderSyncHashCache<T> extends WebGLTextureLoader<T> {\n  // return a unique representation of the input (typically a hash, or anything that can be used as ref identifier)\n  +inputHash: (input: T) => *;\n  // An sync load function that does not cache (WebGLTextureLoaderAsyncHashCache do the caching with inputHash)\n  +getNoCache: (input: T) => TextureAndSize;\n\n  results: Map<*, TextureAndSize> = new Map();\n  promises: Map<*, Promise<TextureAndSize>> = new Map();\n\n  _disposed = false;\n  dispose() {\n    const { gl, results, promises } = this;\n    results.forEach(r => {\n      this.disposeTexture(r.texture);\n    });\n    results.clear();\n    promises.clear();\n    this._disposed = true;\n  }\n\n  disposeTexture(texture: WebGLTexture) {\n    this.gl.deleteTexture(texture);\n  }\n\n  get(input: T) {\n    const hash = this.inputHash(input);\n    const result = this.results.get(hash);\n    if (result) return result;\n    const freshResult = this.getNoCache(input);\n    this.results.set(hash, freshResult);\n    return freshResult;\n  }\n\n  // load() implementation is a dumb fallback on get() but still need to save the promise to guarantee idempotent\n  load(input: T) {\n    const hash = this.inputHash(input);\n    const existing = this.promises.get(hash);\n    if (existing) return existing;\n    const promise = Promise.resolve(this.get(input));\n    this.promises.set(hash, promise);\n    return promise;\n  }\n}\n\nexport default WebGLTextureLoaderSyncHashCache;\n"]}